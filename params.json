{"name":"Business Framework","tagline":"The Caelan.Frameworks.BIZ NuGet Package","body":"#Business Framework\r\n\r\n[![Join the chat at https://gitter.im/Ar3sDevelopment/UnitOfWork.NET](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/Ar3sDevelopment/UnitOfWork.NET?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\nThe UnitOfWork.NET NuGet Package [![NuGet version](https://badge.fury.io/nu/UnitOfWork.NET.svg)](http://badge.fury.io/nu/UnitOfWork.NET)\r\n\r\nIf you need support or you want to contact me I'm [CaelanIt](https://twitter.com/CaelanIt) on Twitter\r\n\r\n##Build\r\nTravis CI (Mono): [![Build Status](https://travis-ci.org/Ar3sDevelopment/UnitOfWork.NET.svg?branch=master)](https://travis-ci.org/Ar3sDevelopment/UnitOfWork.NET)\r\n\r\nAppVeyor (Windows): [![Build status](https://ci.appveyor.com/api/projects/status/arm3x6ls8vulmgin?svg=true)](https://ci.appveyor.com/project/matteobruni/caelan-frameworks-biz)\r\n\r\n##Requests##\r\nPull Requests: [![Issue Stats](http://issuestats.com/github/Ar3sDevelopment/UnitOfWork.NET/badge/pr)](http://issuestats.com/github/Ar3sDevelopment/UnitOfWork.NET)\r\n\r\nIssues: [![Issue Stats](http://issuestats.com/github/Ar3sDevelopment/UnitOfWork.NET/badge/issue)](http://issuestats.com/github/Ar3sDevelopment/UnitOfWork.NET)\r\n\r\nWaffle.io: [![Stories in Ready](https://badge.waffle.io/Ar3sDevelopment/UnitOfWork.NET.png?label=ready&title=Ready)](https://waffle.io/Ar3sDevelopment/UnitOfWork.NET)\r\n\r\n##What is it?\r\nThis package provides some utilities for the business layer like repositories and units of work.\r\n\r\n##`IRepository`\r\nThe `IRepository` interface is the base interface of Repositories used in this framework. It has two methods for getting the linked `IUnitOfWork` instance.\r\n`IRepository` has two methods because you can get a generic `IUnitOfWork` or a custom `UnitOfWork` type.\r\n\r\n###`Repository`\r\nThe `Repository` class implements `IRepository` interface and has a static method for fluent notation for getting a `Repository<TEntity, TDTO>` specifying only `TEntity` and `TDTO`\r\nThis class is abstract because I thought that is useless for other uses.\r\n\r\n###`IRepository<TEntity>`\r\nThe `IRepository<TEntity>` interface inherits from `IRepository` and has more methods than its base and they're business related like basic CRUD operations.\r\n\r\n###`IRepository<TEntity, TDTO>`\r\nThe `IRepository<TEntity, TDTO>` interface inherits from `IRepository<TEntity>` and has more methods than its base and they're business related like basic CRUD operations.\r\n`IRepository<TEntity, TDTO>` has also a method for return paginated result.\r\n\r\n####`Repository<TEntity, TDTO>`\r\nThe `Repository<TEntity, TDTO>` inherits from `Repository` and implements `IRepository<TEntity, TDTO>` interface with some `EntityFramework` code for doing CRUD operations.\r\nIf you need some custom methods you can inherit from `Repository<TEntity, TDTO>` and use all the business ready methods.\r\nSupposing you need a method to get if a user is admin:\r\n```csharp\r\n//Custom `Repository` implemetation class\r\npublic bool IsAdmin(int id)\r\n{\r\n  var user = SingleEntity(id);\r\n  return user != null ? user.Admin : false;\r\n}\r\n```\r\nOr if you need a method that return all admin users:\r\n```csharp\r\n//Custom `Repository` implemetation class\r\npublic IEnumerable<UserDTO> AllAdmins()\r\n{\r\n  return List(t => t.Admin); //DTOs\r\n}\r\n\r\npublic IEnumerable<User> AllAdminsEntities()\r\n{\r\n  return All(t => t.Admin);\r\n}\r\n\r\n//using builders from my Common Framework\r\npublic IEnumerable<UserDTO> AllAdminsEntitiesDTO()\r\n{\r\n  return DTOBuilder().BuildList(AllAdminsEntities());\r\n}\r\n```\r\nLast solution is preferred because you can methods that returns subset of records and when you need DTOs you can simply build them with provided `Builder`s methods: `DTOBuilder()` for Entity to DTO mappings and `EntityBuilder()` for DTO to Entity mappings.\r\nThey use `Builder` class from my Common framework.\r\n\r\nThe paginated result uses method All with pagination parameters. It returns a `DataSourceResult`, that can also be used in WCF, with the page record and the total. `Sort` and `Filter` classes are in my DynamicLinq framework and contains data for sorting and filtering data for the page you need.\r\n\r\n####Accessing to other `Repository` from current\r\nIf you need to use another `Repository` while doing operation in a `Repository` you can use the `UnitOfWork` method for going to container and access to other repositories like explained later.\r\nHere an example:\r\n```csharp\r\npublic bool CheckLogin(string username, string password)\r\n{\r\n  var user = Single(t => t.Username == username && t.Password == passowrd); //not secure!!\r\n  var res = user != null;\r\n\r\n  if (res)\r\n  {\r\n    var access = new UserAccessDTO { IDUser = user.ID, Date = DateTime.Now };\r\n    UnitOfWork().Repository<UserAccess, UserAccessDTO>().Insert(access);\r\n  }\r\n\r\n  return res;\r\n}\r\n```\r\nWith this code you can log a user access without leaving `UserRepository` class and delegate this to the caller method.\r\nRemember to keep `Repository` methods simple and without doing action out of their scope.\r\n\r\n####`IListRepository<TEntity, TDTO, TListDTO>`\r\nThe `IListRepository<TEntity, TDTO, TListDTO>` is an interface that inherits from `IRepository<TEntity, TDTO>` and has only one get-set property for another `IRepository` but for `TEntity` and `TListDTO` so you can have two DTO for the same type, one lighter for reading lists of DTOs and one complete for CRUD operations.\r\nI use it when I have to return data using WCF and data must navigate deep inside objects.\r\n\r\n##`IUnitOfWork`\r\nThe `IUnitOfWork` interface contains base methods for the `UnitOfWork` like transactions, save changes and getting repositories.\r\n\r\n###`UnitOfWork`\r\nThere are two `UnitOfWork` classes, one wants `DbContext` in constructor, the other inherits from this and wants only the `DbContext` type and instantiate it with default constructor.\r\n`UnitOfWork` implements the `IDisposable` interface so you can use it in the `using` closure and it disposes the context only if it's instatiated by the `UnitOfWork` otherwise you will be responsible for it.\r\n`UnitOfWork` class, like `Builder`, uses reflection for getting `IRepository` objects that are unknown. You can get the repository in two ways:\r\n```csharp\r\nusing (var uow = new UnitOfWork<TestDbContext>()) //the uow object is responsible for disposing the context\r\n{\r\n  const int id = 1;\r\n  var user = uow.Repository<User, UserDTO>().SingleDTO(id);\r\n  if (user != null && uow.CustomRepository<UserRepository>().IsAdmin(user.Id))\r\n  {\r\n    //user is admin\r\n  }\r\n  else if (user != null)\r\n  {\r\n    //user exists but is not admin\r\n  }\r\n  else\r\n  {\r\n    //user not found\r\n  }\r\n}\r\n```\r\nThe `user` object is retrieved by `IRepository<TEntity, TDTO>` exposed methods because the repository type is not known at compile time. We can check the admin status by retrieving the repository by type so we know it at compile time and we can use its business related methods like `IsAdmin`.\r\n","google":"UA-57981518-1","note":"Don't delete this file! It's used internally to help with page regeneration."}